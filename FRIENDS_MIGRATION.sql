-- Friends and "Join Workout" System Migration
-- Execute these SQL statements in Supabase Dashboard

-- ============================================
-- TABLE: profiles (if not exists)
-- ============================================
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL,
    username text,
    avatar_url text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Enable RLS on profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles (public viewing for discovery)
CREATE POLICY "Profiles are viewable by everyone" ON public.profiles
  FOR SELECT USING (true);

CREATE POLICY "Users can create own profile" ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can delete own profile" ON public.profiles
  FOR DELETE USING (auth.uid() = id);

-- ============================================
-- TABLE: friendships
-- ============================================
CREATE TABLE IF NOT EXISTS public.friendships (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    requester_id uuid NOT NULL,
    receiver_id uuid NOT NULL,
    status text DEFAULT 'pending'::text CHECK (status IN ('pending', 'accepted', 'rejected', 'blocked')),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    CONSTRAINT friendships_pkey PRIMARY KEY (id),
    CONSTRAINT friendships_requester_id_fkey FOREIGN KEY (requester_id) REFERENCES auth.users(id) ON DELETE CASCADE,
    CONSTRAINT friendships_receiver_id_fkey FOREIGN KEY (receiver_id) REFERENCES auth.users(id) ON DELETE CASCADE,
    CONSTRAINT friendships_no_self_friendship CHECK (requester_id != receiver_id),
    CONSTRAINT friendships_unique_request UNIQUE (requester_id, receiver_id)
);

-- Enable RLS on friendships
ALTER TABLE public.friendships ENABLE ROW LEVEL SECURITY;

-- RLS Policies for friendships
CREATE POLICY "Users can view their own friendship requests" ON public.friendships
  FOR SELECT USING (auth.uid() = requester_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can send friend requests" ON public.friendships
  FOR INSERT WITH CHECK (auth.uid() = requester_id);

CREATE POLICY "Users can accept/reject their own requests" ON public.friendships
  FOR UPDATE USING (auth.uid() = receiver_id);

CREATE POLICY "Users can delete friendship requests" ON public.friendships
  FOR DELETE USING (auth.uid() = requester_id OR auth.uid() = receiver_id);

-- ============================================
-- FUNCTION: is_friend(user_uuid)
-- ============================================
CREATE OR REPLACE FUNCTION public.is_friend(target_user_uuid uuid)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.friendships
    WHERE status = 'accepted'
    AND (
      (requester_id = auth.uid() AND receiver_id = target_user_uuid)
      OR
      (receiver_id = auth.uid() AND requester_id = target_user_uuid)
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- UPDATE RLS on completed_sessions
-- ============================================
-- Add new policy allowing friend access
CREATE POLICY "Users can view friends' sessions" ON public.completed_sessions
  FOR SELECT USING (auth.uid() = user_id OR is_friend(user_id));

-- ============================================
-- INDEXES (for performance)
-- ============================================
CREATE INDEX idx_friendships_requester_id ON public.friendships(requester_id);
CREATE INDEX idx_friendships_receiver_id ON public.friendships(receiver_id);
CREATE INDEX idx_friendships_status ON public.friendships(status);
CREATE INDEX idx_profiles_id ON public.profiles(id);
